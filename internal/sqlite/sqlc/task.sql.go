// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: task.sql

package sqlc

import (
	"context"
	"time"
)

const addTaskCost = `-- name: AddTaskCost :exec
UPDATE task SET cost_usd = cost_usd + ?, updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now') WHERE id = ?
`

type AddTaskCostParams struct {
	CostUsd float64
	ID      string
}

func (q *Queries) AddTaskCost(ctx context.Context, arg AddTaskCostParams) error {
	_, err := q.db.ExecContext(ctx, addTaskCost, arg.CostUsd, arg.ID)
	return err
}

const appendTaskLogs = `-- name: AppendTaskLogs :exec
INSERT INTO task_log (task_id, attempt, lines) VALUES (?, ?, ?)
`

type AppendTaskLogsParams struct {
	TaskID  string
	Attempt int64
	Lines   string
}

func (q *Queries) AppendTaskLogs(ctx context.Context, arg AppendTaskLogsParams) error {
	_, err := q.db.ExecContext(ctx, appendTaskLogs, arg.TaskID, arg.Attempt, arg.Lines)
	return err
}

const claimTask = `-- name: ClaimTask :execrows
UPDATE task SET status = 'running', updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ? AND status = 'pending'
`

func (q *Queries) ClaimTask(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, claimTask, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const closeTask = `-- name: CloseTask :exec
UPDATE task SET status = 'closed', close_reason = ?, updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ?
`

type CloseTaskParams struct {
	CloseReason *string
	ID          string
}

func (q *Queries) CloseTask(ctx context.Context, arg CloseTaskParams) error {
	_, err := q.db.ExecContext(ctx, closeTask, arg.CloseReason, arg.ID)
	return err
}

const createTask = `-- name: CreateTask :exec
INSERT INTO task (id, repo_id, title, description, status, depends_on, attempt, max_attempts, acceptance_criteria_list, max_cost_usd, skip_pr, model, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateTaskParams struct {
	ID                     string
	RepoID                 string
	Title                  string
	Description            string
	Status                 string
	DependsOn              string
	Attempt                int64
	MaxAttempts            int64
	AcceptanceCriteriaList string
	MaxCostUsd             *float64
	SkipPr                 int64
	Model                  *string
	CreatedAt              time.Time
	UpdatedAt              time.Time
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) error {
	_, err := q.db.ExecContext(ctx, createTask,
		arg.ID,
		arg.RepoID,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.DependsOn,
		arg.Attempt,
		arg.MaxAttempts,
		arg.AcceptanceCriteriaList,
		arg.MaxCostUsd,
		arg.SkipPr,
		arg.Model,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteTaskLogs = `-- name: DeleteTaskLogs :exec
DELETE FROM task_log WHERE task_id = ?
`

func (q *Queries) DeleteTaskLogs(ctx context.Context, taskID string) error {
	_, err := q.db.ExecContext(ctx, deleteTaskLogs, taskID)
	return err
}

const hasTasksForRepo = `-- name: HasTasksForRepo :one
SELECT EXISTS(SELECT 1 FROM task WHERE repo_id = ?)
`

func (q *Queries) HasTasksForRepo(ctx context.Context, repoID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, hasTasksForRepo, repoID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const listPendingTasks = `-- name: ListPendingTasks :many
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, acceptance_criteria, agent_status, retry_context, consecutive_failures, cost_usd, max_cost_usd, created_at, updated_at, skip_pr, branch_name, title, acceptance_criteria_list, model FROM task WHERE status = 'pending' ORDER BY created_at ASC
`

func (q *Queries) ListPendingTasks(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.QueryContext(ctx, listPendingTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Description,
			&i.Status,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.Attempt,
			&i.MaxAttempts,
			&i.RetryReason,
			&i.AcceptanceCriteria,
			&i.AgentStatus,
			&i.RetryContext,
			&i.ConsecutiveFailures,
			&i.CostUsd,
			&i.MaxCostUsd,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SkipPr,
			&i.BranchName,
			&i.Title,
			&i.AcceptanceCriteriaList,
			&i.Model,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasks = `-- name: ListTasks :many
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, acceptance_criteria, agent_status, retry_context, consecutive_failures, cost_usd, max_cost_usd, created_at, updated_at, skip_pr, branch_name, title, acceptance_criteria_list, model FROM task ORDER BY created_at DESC
`

func (q *Queries) ListTasks(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.QueryContext(ctx, listTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Description,
			&i.Status,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.Attempt,
			&i.MaxAttempts,
			&i.RetryReason,
			&i.AcceptanceCriteria,
			&i.AgentStatus,
			&i.RetryContext,
			&i.ConsecutiveFailures,
			&i.CostUsd,
			&i.MaxCostUsd,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SkipPr,
			&i.BranchName,
			&i.Title,
			&i.AcceptanceCriteriaList,
			&i.Model,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksByRepo = `-- name: ListTasksByRepo :many
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, acceptance_criteria, agent_status, retry_context, consecutive_failures, cost_usd, max_cost_usd, created_at, updated_at, skip_pr, branch_name, title, acceptance_criteria_list, model FROM task WHERE repo_id = ? ORDER BY created_at DESC
`

func (q *Queries) ListTasksByRepo(ctx context.Context, repoID string) ([]*Task, error) {
	rows, err := q.db.QueryContext(ctx, listTasksByRepo, repoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Description,
			&i.Status,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.Attempt,
			&i.MaxAttempts,
			&i.RetryReason,
			&i.AcceptanceCriteria,
			&i.AgentStatus,
			&i.RetryContext,
			&i.ConsecutiveFailures,
			&i.CostUsd,
			&i.MaxCostUsd,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SkipPr,
			&i.BranchName,
			&i.Title,
			&i.AcceptanceCriteriaList,
			&i.Model,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksInReview = `-- name: ListTasksInReview :many
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, acceptance_criteria, agent_status, retry_context, consecutive_failures, cost_usd, max_cost_usd, created_at, updated_at, skip_pr, branch_name, title, acceptance_criteria_list, model FROM task WHERE status = 'review'
`

func (q *Queries) ListTasksInReview(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.QueryContext(ctx, listTasksInReview)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Description,
			&i.Status,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.Attempt,
			&i.MaxAttempts,
			&i.RetryReason,
			&i.AcceptanceCriteria,
			&i.AgentStatus,
			&i.RetryContext,
			&i.ConsecutiveFailures,
			&i.CostUsd,
			&i.MaxCostUsd,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SkipPr,
			&i.BranchName,
			&i.Title,
			&i.AcceptanceCriteriaList,
			&i.Model,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksInReviewByRepo = `-- name: ListTasksInReviewByRepo :many
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, acceptance_criteria, agent_status, retry_context, consecutive_failures, cost_usd, max_cost_usd, created_at, updated_at, skip_pr, branch_name, title, acceptance_criteria_list, model FROM task WHERE repo_id = ? AND status = 'review'
`

func (q *Queries) ListTasksInReviewByRepo(ctx context.Context, repoID string) ([]*Task, error) {
	rows, err := q.db.QueryContext(ctx, listTasksInReviewByRepo, repoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Description,
			&i.Status,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.Attempt,
			&i.MaxAttempts,
			&i.RetryReason,
			&i.AcceptanceCriteria,
			&i.AgentStatus,
			&i.RetryContext,
			&i.ConsecutiveFailures,
			&i.CostUsd,
			&i.MaxCostUsd,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SkipPr,
			&i.BranchName,
			&i.Title,
			&i.AcceptanceCriteriaList,
			&i.Model,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksInReviewNoPR = `-- name: ListTasksInReviewNoPR :many
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, acceptance_criteria, agent_status, retry_context, consecutive_failures, cost_usd, max_cost_usd, created_at, updated_at, skip_pr, branch_name, title, acceptance_criteria_list, model FROM task WHERE status = 'review' AND branch_name IS NOT NULL AND pr_number IS NULL
`

func (q *Queries) ListTasksInReviewNoPR(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.QueryContext(ctx, listTasksInReviewNoPR)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Description,
			&i.Status,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.Attempt,
			&i.MaxAttempts,
			&i.RetryReason,
			&i.AcceptanceCriteria,
			&i.AgentStatus,
			&i.RetryContext,
			&i.ConsecutiveFailures,
			&i.CostUsd,
			&i.MaxCostUsd,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SkipPr,
			&i.BranchName,
			&i.Title,
			&i.AcceptanceCriteriaList,
			&i.Model,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const manualRetryTask = `-- name: ManualRetryTask :execrows
UPDATE task SET status = 'pending', attempt = attempt + 1,
  retry_reason = ?, retry_context = NULL, agent_status = NULL,
  close_reason = NULL, consecutive_failures = 0,
  pull_request_url = NULL, pr_number = NULL, branch_name = NULL,
  updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ? AND status = 'failed'
`

type ManualRetryTaskParams struct {
	RetryReason *string
	ID          string
}

func (q *Queries) ManualRetryTask(ctx context.Context, arg ManualRetryTaskParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, manualRetryTask, arg.RetryReason, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const readTask = `-- name: ReadTask :one
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, acceptance_criteria, agent_status, retry_context, consecutive_failures, cost_usd, max_cost_usd, created_at, updated_at, skip_pr, branch_name, title, acceptance_criteria_list, model FROM task WHERE id = ?
`

func (q *Queries) ReadTask(ctx context.Context, id string) (*Task, error) {
	row := q.db.QueryRowContext(ctx, readTask, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.RepoID,
		&i.Description,
		&i.Status,
		&i.PullRequestUrl,
		&i.PrNumber,
		&i.DependsOn,
		&i.CloseReason,
		&i.Attempt,
		&i.MaxAttempts,
		&i.RetryReason,
		&i.AcceptanceCriteria,
		&i.AgentStatus,
		&i.RetryContext,
		&i.ConsecutiveFailures,
		&i.CostUsd,
		&i.MaxCostUsd,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SkipPr,
		&i.BranchName,
		&i.Title,
		&i.AcceptanceCriteriaList,
		&i.Model,
	)
	return &i, err
}

const readTaskLogs = `-- name: ReadTaskLogs :many
SELECT attempt, lines FROM task_log WHERE task_id = ? ORDER BY id
`

type ReadTaskLogsRow struct {
	Attempt int64
	Lines   string
}

func (q *Queries) ReadTaskLogs(ctx context.Context, taskID string) ([]*ReadTaskLogsRow, error) {
	rows, err := q.db.QueryContext(ctx, readTaskLogs, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ReadTaskLogsRow
	for rows.Next() {
		var i ReadTaskLogsRow
		if err := rows.Scan(&i.Attempt, &i.Lines); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readTaskStatus = `-- name: ReadTaskStatus :one
SELECT status FROM task WHERE id = ?
`

func (q *Queries) ReadTaskStatus(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRowContext(ctx, readTaskStatus, id)
	var status string
	err := row.Scan(&status)
	return status, err
}

const retryTask = `-- name: RetryTask :execrows
UPDATE task SET status = 'pending', attempt = attempt + 1, retry_reason = ?, agent_status = NULL, updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ? AND status = 'review'
`

type RetryTaskParams struct {
	RetryReason *string
	ID          string
}

func (q *Queries) RetryTask(ctx context.Context, arg RetryTaskParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, retryTask, arg.RetryReason, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const setAgentStatus = `-- name: SetAgentStatus :exec
UPDATE task SET agent_status = ?, updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now') WHERE id = ?
`

type SetAgentStatusParams struct {
	AgentStatus *string
	ID          string
}

func (q *Queries) SetAgentStatus(ctx context.Context, arg SetAgentStatusParams) error {
	_, err := q.db.ExecContext(ctx, setAgentStatus, arg.AgentStatus, arg.ID)
	return err
}

const setBranchName = `-- name: SetBranchName :exec
UPDATE task SET branch_name = ?, status = 'review', updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now') WHERE id = ?
`

type SetBranchNameParams struct {
	BranchName *string
	ID         string
}

func (q *Queries) SetBranchName(ctx context.Context, arg SetBranchNameParams) error {
	_, err := q.db.ExecContext(ctx, setBranchName, arg.BranchName, arg.ID)
	return err
}

const setCloseReason = `-- name: SetCloseReason :exec
UPDATE task SET close_reason = ?, updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now') WHERE id = ?
`

type SetCloseReasonParams struct {
	CloseReason *string
	ID          string
}

func (q *Queries) SetCloseReason(ctx context.Context, arg SetCloseReasonParams) error {
	_, err := q.db.ExecContext(ctx, setCloseReason, arg.CloseReason, arg.ID)
	return err
}

const setConsecutiveFailures = `-- name: SetConsecutiveFailures :exec
UPDATE task SET consecutive_failures = ?, updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now') WHERE id = ?
`

type SetConsecutiveFailuresParams struct {
	ConsecutiveFailures int64
	ID                  string
}

func (q *Queries) SetConsecutiveFailures(ctx context.Context, arg SetConsecutiveFailuresParams) error {
	_, err := q.db.ExecContext(ctx, setConsecutiveFailures, arg.ConsecutiveFailures, arg.ID)
	return err
}

const setRetryContext = `-- name: SetRetryContext :exec
UPDATE task SET retry_context = ?, updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now') WHERE id = ?
`

type SetRetryContextParams struct {
	RetryContext *string
	ID           string
}

func (q *Queries) SetRetryContext(ctx context.Context, arg SetRetryContextParams) error {
	_, err := q.db.ExecContext(ctx, setRetryContext, arg.RetryContext, arg.ID)
	return err
}

const setTaskPullRequest = `-- name: SetTaskPullRequest :exec
UPDATE task SET pull_request_url = ?, pr_number = ?, status = 'review', updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ?
`

type SetTaskPullRequestParams struct {
	PullRequestUrl *string
	PrNumber       *int64
	ID             string
}

func (q *Queries) SetTaskPullRequest(ctx context.Context, arg SetTaskPullRequestParams) error {
	_, err := q.db.ExecContext(ctx, setTaskPullRequest, arg.PullRequestUrl, arg.PrNumber, arg.ID)
	return err
}

const taskExists = `-- name: TaskExists :one
SELECT EXISTS(SELECT 1 FROM task WHERE id = ?)
`

func (q *Queries) TaskExists(ctx context.Context, id string) (int64, error) {
	row := q.db.QueryRowContext(ctx, taskExists, id)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const updateTaskStatus = `-- name: UpdateTaskStatus :exec
UPDATE task SET status = ?, updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ?
`

type UpdateTaskStatusParams struct {
	Status string
	ID     string
}

func (q *Queries) UpdateTaskStatus(ctx context.Context, arg UpdateTaskStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateTaskStatus, arg.Status, arg.ID)
	return err
}
