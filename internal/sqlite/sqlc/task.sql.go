// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: task.sql

package sqlc

import (
	"context"
	"time"
)

const appendTaskLogs = `-- name: AppendTaskLogs :exec
INSERT INTO task_log (task_id, lines) VALUES (?, ?)
`

type AppendTaskLogsParams struct {
	TaskID string
	Lines  string
}

func (q *Queries) AppendTaskLogs(ctx context.Context, arg AppendTaskLogsParams) error {
	_, err := q.db.ExecContext(ctx, appendTaskLogs, arg.TaskID, arg.Lines)
	return err
}

const claimTask = `-- name: ClaimTask :execrows
UPDATE task SET status = 'running', updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ? AND status = 'pending'
`

func (q *Queries) ClaimTask(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, claimTask, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const closeTask = `-- name: CloseTask :exec
UPDATE task SET status = 'closed', close_reason = ?, updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ?
`

type CloseTaskParams struct {
	CloseReason *string
	ID          string
}

func (q *Queries) CloseTask(ctx context.Context, arg CloseTaskParams) error {
	_, err := q.db.ExecContext(ctx, closeTask, arg.CloseReason, arg.ID)
	return err
}

const createTask = `-- name: CreateTask :exec
INSERT INTO task (id, repo_id, description, status, depends_on, attempt, max_attempts, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateTaskParams struct {
	ID          string
	RepoID      string
	Description string
	Status      string
	DependsOn   string
	Attempt     int64
	MaxAttempts int64
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) error {
	_, err := q.db.ExecContext(ctx, createTask,
		arg.ID,
		arg.RepoID,
		arg.Description,
		arg.Status,
		arg.DependsOn,
		arg.Attempt,
		arg.MaxAttempts,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const hasTasksForRepo = `-- name: HasTasksForRepo :one
SELECT EXISTS(SELECT 1 FROM task WHERE repo_id = ?)
`

func (q *Queries) HasTasksForRepo(ctx context.Context, repoID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, hasTasksForRepo, repoID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const listPendingTasks = `-- name: ListPendingTasks :many
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, created_at, updated_at FROM task WHERE status = 'pending' ORDER BY created_at ASC
`

func (q *Queries) ListPendingTasks(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.QueryContext(ctx, listPendingTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Description,
			&i.Status,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.Attempt,
			&i.MaxAttempts,
			&i.RetryReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasks = `-- name: ListTasks :many
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, created_at, updated_at FROM task ORDER BY created_at DESC
`

func (q *Queries) ListTasks(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.QueryContext(ctx, listTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Description,
			&i.Status,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.Attempt,
			&i.MaxAttempts,
			&i.RetryReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksByRepo = `-- name: ListTasksByRepo :many
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, created_at, updated_at FROM task WHERE repo_id = ? ORDER BY created_at DESC
`

func (q *Queries) ListTasksByRepo(ctx context.Context, repoID string) ([]*Task, error) {
	rows, err := q.db.QueryContext(ctx, listTasksByRepo, repoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Description,
			&i.Status,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.Attempt,
			&i.MaxAttempts,
			&i.RetryReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksInReview = `-- name: ListTasksInReview :many
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, created_at, updated_at FROM task WHERE status = 'review'
`

func (q *Queries) ListTasksInReview(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.QueryContext(ctx, listTasksInReview)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Description,
			&i.Status,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.Attempt,
			&i.MaxAttempts,
			&i.RetryReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksInReviewByRepo = `-- name: ListTasksInReviewByRepo :many
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, created_at, updated_at FROM task WHERE repo_id = ? AND status = 'review'
`

func (q *Queries) ListTasksInReviewByRepo(ctx context.Context, repoID string) ([]*Task, error) {
	rows, err := q.db.QueryContext(ctx, listTasksInReviewByRepo, repoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Description,
			&i.Status,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.Attempt,
			&i.MaxAttempts,
			&i.RetryReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readTask = `-- name: ReadTask :one
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, created_at, updated_at FROM task WHERE id = ?
`

func (q *Queries) ReadTask(ctx context.Context, id string) (*Task, error) {
	row := q.db.QueryRowContext(ctx, readTask, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.RepoID,
		&i.Description,
		&i.Status,
		&i.PullRequestUrl,
		&i.PrNumber,
		&i.DependsOn,
		&i.CloseReason,
		&i.Attempt,
		&i.MaxAttempts,
		&i.RetryReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const readTaskLogs = `-- name: ReadTaskLogs :many
SELECT lines FROM task_log WHERE task_id = ? ORDER BY id
`

func (q *Queries) ReadTaskLogs(ctx context.Context, taskID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, readTaskLogs, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var lines string
		if err := rows.Scan(&lines); err != nil {
			return nil, err
		}
		items = append(items, lines)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readTaskStatus = `-- name: ReadTaskStatus :one
SELECT status FROM task WHERE id = ?
`

func (q *Queries) ReadTaskStatus(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRowContext(ctx, readTaskStatus, id)
	var status string
	err := row.Scan(&status)
	return status, err
}

const retryTask = `-- name: RetryTask :execrows
UPDATE task SET status = 'pending', attempt = attempt + 1, retry_reason = ?, updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ? AND status = 'review'
`

type RetryTaskParams struct {
	RetryReason *string
	ID          string
}

func (q *Queries) RetryTask(ctx context.Context, arg RetryTaskParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, retryTask, arg.RetryReason, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const setTaskPullRequest = `-- name: SetTaskPullRequest :exec
UPDATE task SET pull_request_url = ?, pr_number = ?, status = 'review', updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ?
`

type SetTaskPullRequestParams struct {
	PullRequestUrl *string
	PrNumber       *int64
	ID             string
}

func (q *Queries) SetTaskPullRequest(ctx context.Context, arg SetTaskPullRequestParams) error {
	_, err := q.db.ExecContext(ctx, setTaskPullRequest, arg.PullRequestUrl, arg.PrNumber, arg.ID)
	return err
}

const taskExists = `-- name: TaskExists :one
SELECT EXISTS(SELECT 1 FROM task WHERE id = ?)
`

func (q *Queries) TaskExists(ctx context.Context, id string) (int64, error) {
	row := q.db.QueryRowContext(ctx, taskExists, id)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const updateTaskStatus = `-- name: UpdateTaskStatus :exec
UPDATE task SET status = ?, updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ?
`

type UpdateTaskStatusParams struct {
	Status string
	ID     string
}

func (q *Queries) UpdateTaskStatus(ctx context.Context, arg UpdateTaskStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateTaskStatus, arg.Status, arg.ID)
	return err
}
