// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: task.sql

package sqlc

import (
	"context"
	"time"
)

const claimTask = `-- name: ClaimTask :execrows
UPDATE task SET status = 'running', updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ? AND status = 'pending'
`

func (q *Queries) ClaimTask(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, claimTask, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const closeTask = `-- name: CloseTask :exec
UPDATE task SET status = 'closed', close_reason = ?, updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ?
`

type CloseTaskParams struct {
	CloseReason *string
	ID          string
}

func (q *Queries) CloseTask(ctx context.Context, arg CloseTaskParams) error {
	_, err := q.db.ExecContext(ctx, closeTask, arg.CloseReason, arg.ID)
	return err
}

const createTask = `-- name: CreateTask :exec
INSERT INTO task (id, description, status, logs, depends_on, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateTaskParams struct {
	ID          string
	Description string
	Status      string
	Logs        string
	DependsOn   string
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) error {
	_, err := q.db.ExecContext(ctx, createTask,
		arg.ID,
		arg.Description,
		arg.Status,
		arg.Logs,
		arg.DependsOn,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const listPendingTasks = `-- name: ListPendingTasks :many
SELECT id, description, status, logs, pull_request_url, pr_number, depends_on, close_reason, created_at, updated_at FROM task WHERE status = 'pending' ORDER BY created_at ASC
`

func (q *Queries) ListPendingTasks(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.QueryContext(ctx, listPendingTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Status,
			&i.Logs,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasks = `-- name: ListTasks :many
SELECT id, description, status, logs, pull_request_url, pr_number, depends_on, close_reason, created_at, updated_at FROM task ORDER BY created_at DESC
`

func (q *Queries) ListTasks(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.QueryContext(ctx, listTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Status,
			&i.Logs,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksInReview = `-- name: ListTasksInReview :many
SELECT id, description, status, logs, pull_request_url, pr_number, depends_on, close_reason, created_at, updated_at FROM task WHERE status = 'review'
`

func (q *Queries) ListTasksInReview(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.QueryContext(ctx, listTasksInReview)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Status,
			&i.Logs,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readTask = `-- name: ReadTask :one
SELECT id, description, status, logs, pull_request_url, pr_number, depends_on, close_reason, created_at, updated_at FROM task WHERE id = ?
`

func (q *Queries) ReadTask(ctx context.Context, id string) (*Task, error) {
	row := q.db.QueryRowContext(ctx, readTask, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Status,
		&i.Logs,
		&i.PullRequestUrl,
		&i.PrNumber,
		&i.DependsOn,
		&i.CloseReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const readTaskLogs = `-- name: ReadTaskLogs :one
SELECT logs FROM task WHERE id = ?
`

func (q *Queries) ReadTaskLogs(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRowContext(ctx, readTaskLogs, id)
	var logs string
	err := row.Scan(&logs)
	return logs, err
}

const readTaskStatus = `-- name: ReadTaskStatus :one
SELECT status FROM task WHERE id = ?
`

func (q *Queries) ReadTaskStatus(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRowContext(ctx, readTaskStatus, id)
	var status string
	err := row.Scan(&status)
	return status, err
}

const setTaskLogs = `-- name: SetTaskLogs :exec
UPDATE task SET logs = ?, updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ?
`

type SetTaskLogsParams struct {
	Logs string
	ID   string
}

func (q *Queries) SetTaskLogs(ctx context.Context, arg SetTaskLogsParams) error {
	_, err := q.db.ExecContext(ctx, setTaskLogs, arg.Logs, arg.ID)
	return err
}

const setTaskPullRequest = `-- name: SetTaskPullRequest :exec
UPDATE task SET pull_request_url = ?, pr_number = ?, status = 'review', updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ?
`

type SetTaskPullRequestParams struct {
	PullRequestUrl *string
	PrNumber       *int64
	ID             string
}

func (q *Queries) SetTaskPullRequest(ctx context.Context, arg SetTaskPullRequestParams) error {
	_, err := q.db.ExecContext(ctx, setTaskPullRequest, arg.PullRequestUrl, arg.PrNumber, arg.ID)
	return err
}

const taskExists = `-- name: TaskExists :one
SELECT EXISTS(SELECT 1 FROM task WHERE id = ?)
`

func (q *Queries) TaskExists(ctx context.Context, id string) (int64, error) {
	row := q.db.QueryRowContext(ctx, taskExists, id)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const updateTaskStatus = `-- name: UpdateTaskStatus :exec
UPDATE task SET status = ?, updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ?
`

type UpdateTaskStatusParams struct {
	Status string
	ID     string
}

func (q *Queries) UpdateTaskStatus(ctx context.Context, arg UpdateTaskStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateTaskStatus, arg.Status, arg.ID)
	return err
}
