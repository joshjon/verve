// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: epic.sql

package sqlc

import (
	"context"
	"time"
)

const appendSessionLog = `-- name: AppendSessionLog :exec
UPDATE epic SET session_log = ?, updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ?
`

type AppendSessionLogParams struct {
	SessionLog string
	ID         string
}

func (q *Queries) AppendSessionLog(ctx context.Context, arg AppendSessionLogParams) error {
	_, err := q.db.ExecContext(ctx, appendSessionLog, arg.SessionLog, arg.ID)
	return err
}

const claimEpic = `-- name: ClaimEpic :execrows
UPDATE epic SET
  claimed_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now'),
  last_heartbeat_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now'),
  updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ? AND status = 'planning' AND claimed_at IS NULL
`

func (q *Queries) ClaimEpic(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, claimEpic, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const clearEpicFeedback = `-- name: ClearEpicFeedback :exec
UPDATE epic SET
  feedback = NULL,
  feedback_type = NULL,
  updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ?
`

func (q *Queries) ClearEpicFeedback(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, clearEpicFeedback, id)
	return err
}

const createEpic = `-- name: CreateEpic :exec
INSERT INTO epic (id, repo_id, title, description, status, proposed_tasks, task_ids, planning_prompt, session_log, not_ready, model, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateEpicParams struct {
	ID             string
	RepoID         string
	Title          string
	Description    string
	Status         string
	ProposedTasks  string
	TaskIds        string
	PlanningPrompt *string
	SessionLog     string
	NotReady       int64
	Model          *string
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

func (q *Queries) CreateEpic(ctx context.Context, arg CreateEpicParams) error {
	_, err := q.db.ExecContext(ctx, createEpic,
		arg.ID,
		arg.RepoID,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.ProposedTasks,
		arg.TaskIds,
		arg.PlanningPrompt,
		arg.SessionLog,
		arg.NotReady,
		arg.Model,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteEpic = `-- name: DeleteEpic :exec
DELETE FROM epic WHERE id = ?
`

func (q *Queries) DeleteEpic(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteEpic, id)
	return err
}

const epicHeartbeat = `-- name: EpicHeartbeat :exec
UPDATE epic SET
  last_heartbeat_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now'),
  updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ?
`

func (q *Queries) EpicHeartbeat(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, epicHeartbeat, id)
	return err
}

const listActiveEpics = `-- name: ListActiveEpics :many
SELECT id, repo_id, title, description, status, proposed_tasks, task_ids, planning_prompt, session_log, not_ready, created_at, updated_at, claimed_at, last_heartbeat_at, feedback, feedback_type, model FROM epic
WHERE status = 'active'
ORDER BY created_at ASC
`

func (q *Queries) ListActiveEpics(ctx context.Context) ([]*Epic, error) {
	rows, err := q.db.QueryContext(ctx, listActiveEpics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Epic
	for rows.Next() {
		var i Epic
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.ProposedTasks,
			&i.TaskIds,
			&i.PlanningPrompt,
			&i.SessionLog,
			&i.NotReady,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClaimedAt,
			&i.LastHeartbeatAt,
			&i.Feedback,
			&i.FeedbackType,
			&i.Model,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpics = `-- name: ListEpics :many
SELECT id, repo_id, title, description, status, proposed_tasks, task_ids, planning_prompt, session_log, not_ready, created_at, updated_at, claimed_at, last_heartbeat_at, feedback, feedback_type, model FROM epic ORDER BY created_at DESC
`

func (q *Queries) ListEpics(ctx context.Context) ([]*Epic, error) {
	rows, err := q.db.QueryContext(ctx, listEpics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Epic
	for rows.Next() {
		var i Epic
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.ProposedTasks,
			&i.TaskIds,
			&i.PlanningPrompt,
			&i.SessionLog,
			&i.NotReady,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClaimedAt,
			&i.LastHeartbeatAt,
			&i.Feedback,
			&i.FeedbackType,
			&i.Model,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpicsByRepo = `-- name: ListEpicsByRepo :many
SELECT id, repo_id, title, description, status, proposed_tasks, task_ids, planning_prompt, session_log, not_ready, created_at, updated_at, claimed_at, last_heartbeat_at, feedback, feedback_type, model FROM epic WHERE repo_id = ? ORDER BY created_at DESC
`

func (q *Queries) ListEpicsByRepo(ctx context.Context, repoID string) ([]*Epic, error) {
	rows, err := q.db.QueryContext(ctx, listEpicsByRepo, repoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Epic
	for rows.Next() {
		var i Epic
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.ProposedTasks,
			&i.TaskIds,
			&i.PlanningPrompt,
			&i.SessionLog,
			&i.NotReady,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClaimedAt,
			&i.LastHeartbeatAt,
			&i.Feedback,
			&i.FeedbackType,
			&i.Model,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlanningEpics = `-- name: ListPlanningEpics :many
SELECT id, repo_id, title, description, status, proposed_tasks, task_ids, planning_prompt, session_log, not_ready, created_at, updated_at, claimed_at, last_heartbeat_at, feedback, feedback_type, model FROM epic
WHERE status = 'planning' AND claimed_at IS NULL
ORDER BY created_at ASC
`

func (q *Queries) ListPlanningEpics(ctx context.Context) ([]*Epic, error) {
	rows, err := q.db.QueryContext(ctx, listPlanningEpics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Epic
	for rows.Next() {
		var i Epic
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.ProposedTasks,
			&i.TaskIds,
			&i.PlanningPrompt,
			&i.SessionLog,
			&i.NotReady,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClaimedAt,
			&i.LastHeartbeatAt,
			&i.Feedback,
			&i.FeedbackType,
			&i.Model,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStaleEpics = `-- name: ListStaleEpics :many
SELECT id, repo_id, title, description, status, proposed_tasks, task_ids, planning_prompt, session_log, not_ready, created_at, updated_at, claimed_at, last_heartbeat_at, feedback, feedback_type, model FROM epic
WHERE claimed_at IS NOT NULL
  AND last_heartbeat_at < ?
  AND status IN ('planning', 'draft')
ORDER BY last_heartbeat_at ASC
`

func (q *Queries) ListStaleEpics(ctx context.Context, lastHeartbeatAt *time.Time) ([]*Epic, error) {
	rows, err := q.db.QueryContext(ctx, listStaleEpics, lastHeartbeatAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Epic
	for rows.Next() {
		var i Epic
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.ProposedTasks,
			&i.TaskIds,
			&i.PlanningPrompt,
			&i.SessionLog,
			&i.NotReady,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClaimedAt,
			&i.LastHeartbeatAt,
			&i.Feedback,
			&i.FeedbackType,
			&i.Model,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readEpic = `-- name: ReadEpic :one
SELECT id, repo_id, title, description, status, proposed_tasks, task_ids, planning_prompt, session_log, not_ready, created_at, updated_at, claimed_at, last_heartbeat_at, feedback, feedback_type, model FROM epic WHERE id = ?
`

func (q *Queries) ReadEpic(ctx context.Context, id string) (*Epic, error) {
	row := q.db.QueryRowContext(ctx, readEpic, id)
	var i Epic
	err := row.Scan(
		&i.ID,
		&i.RepoID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.ProposedTasks,
		&i.TaskIds,
		&i.PlanningPrompt,
		&i.SessionLog,
		&i.NotReady,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClaimedAt,
		&i.LastHeartbeatAt,
		&i.Feedback,
		&i.FeedbackType,
		&i.Model,
	)
	return &i, err
}

const releaseEpicClaim = `-- name: ReleaseEpicClaim :exec
UPDATE epic SET
  claimed_at = NULL,
  last_heartbeat_at = NULL,
  status = 'planning',
  updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ?
`

func (q *Queries) ReleaseEpicClaim(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, releaseEpicClaim, id)
	return err
}

const setEpicFeedback = `-- name: SetEpicFeedback :exec
UPDATE epic SET
  feedback = ?,
  feedback_type = ?,
  updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ?
`

type SetEpicFeedbackParams struct {
	Feedback     *string
	FeedbackType *string
	ID           string
}

func (q *Queries) SetEpicFeedback(ctx context.Context, arg SetEpicFeedbackParams) error {
	_, err := q.db.ExecContext(ctx, setEpicFeedback, arg.Feedback, arg.FeedbackType, arg.ID)
	return err
}

const setEpicTaskIDs = `-- name: SetEpicTaskIDs :exec
UPDATE epic SET task_ids = ?, updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ?
`

type SetEpicTaskIDsParams struct {
	TaskIds string
	ID      string
}

func (q *Queries) SetEpicTaskIDs(ctx context.Context, arg SetEpicTaskIDsParams) error {
	_, err := q.db.ExecContext(ctx, setEpicTaskIDs, arg.TaskIds, arg.ID)
	return err
}

const updateEpic = `-- name: UpdateEpic :exec
UPDATE epic SET
  title = ?,
  description = ?,
  status = ?,
  proposed_tasks = ?,
  task_ids = ?,
  planning_prompt = ?,
  session_log = ?,
  not_ready = ?,
  model = ?,
  updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ?
`

type UpdateEpicParams struct {
	Title          string
	Description    string
	Status         string
	ProposedTasks  string
	TaskIds        string
	PlanningPrompt *string
	SessionLog     string
	NotReady       int64
	Model          *string
	ID             string
}

func (q *Queries) UpdateEpic(ctx context.Context, arg UpdateEpicParams) error {
	_, err := q.db.ExecContext(ctx, updateEpic,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.ProposedTasks,
		arg.TaskIds,
		arg.PlanningPrompt,
		arg.SessionLog,
		arg.NotReady,
		arg.Model,
		arg.ID,
	)
	return err
}

const updateEpicStatus = `-- name: UpdateEpicStatus :exec
UPDATE epic SET status = ?, updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ?
`

type UpdateEpicStatusParams struct {
	Status string
	ID     string
}

func (q *Queries) UpdateEpicStatus(ctx context.Context, arg UpdateEpicStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateEpicStatus, arg.Status, arg.ID)
	return err
}

const updateProposedTasks = `-- name: UpdateProposedTasks :exec
UPDATE epic SET proposed_tasks = ?, updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
WHERE id = ?
`

type UpdateProposedTasksParams struct {
	ProposedTasks string
	ID            string
}

func (q *Queries) UpdateProposedTasks(ctx context.Context, arg UpdateProposedTasksParams) error {
	_, err := q.db.ExecContext(ctx, updateProposedTasks, arg.ProposedTasks, arg.ID)
	return err
}
