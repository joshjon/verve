// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: task.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addTaskCost = `-- name: AddTaskCost :exec
UPDATE task SET cost_usd = cost_usd + $2, updated_at = NOW() WHERE id = $1
`

type AddTaskCostParams struct {
	ID      string  `json:"id"`
	CostUsd float64 `json:"cost_usd"`
}

func (q *Queries) AddTaskCost(ctx context.Context, arg AddTaskCostParams) error {
	_, err := q.db.Exec(ctx, addTaskCost, arg.ID, arg.CostUsd)
	return err
}

const appendTaskLogs = `-- name: AppendTaskLogs :exec
INSERT INTO task_log (task_id, attempt, lines) VALUES ($1, $2, $3)
`

type AppendTaskLogsParams struct {
	ID      string   `json:"id"`
	Attempt int32    `json:"attempt"`
	Lines   []string `json:"lines"`
}

func (q *Queries) AppendTaskLogs(ctx context.Context, arg AppendTaskLogsParams) error {
	_, err := q.db.Exec(ctx, appendTaskLogs, arg.ID, arg.Attempt, arg.Lines)
	return err
}

const claimTask = `-- name: ClaimTask :execrows
UPDATE task SET status = 'running', started_at = NOW(), updated_at = NOW()
WHERE id = $1 AND status = 'pending'
`

func (q *Queries) ClaimTask(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, claimTask, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const closeTask = `-- name: CloseTask :exec
UPDATE task SET status = 'closed', close_reason = $2, updated_at = NOW()
WHERE id = $1
`

type CloseTaskParams struct {
	ID          string  `json:"id"`
	CloseReason *string `json:"close_reason"`
}

func (q *Queries) CloseTask(ctx context.Context, arg CloseTaskParams) error {
	_, err := q.db.Exec(ctx, closeTask, arg.ID, arg.CloseReason)
	return err
}

const createTask = `-- name: CreateTask :exec
INSERT INTO task (id, repo_id, title, description, status, depends_on, attempt, max_attempts, acceptance_criteria_list, max_cost_usd, skip_pr, model, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
`

type CreateTaskParams struct {
	ID                     string             `json:"id"`
	RepoID                 string             `json:"repo_id"`
	Title                  string             `json:"title"`
	Description            string             `json:"description"`
	Status                 TaskStatus         `json:"status"`
	DependsOn              []string           `json:"depends_on"`
	Attempt                int32              `json:"attempt"`
	MaxAttempts            int32              `json:"max_attempts"`
	AcceptanceCriteriaList []string           `json:"acceptance_criteria_list"`
	MaxCostUsd             *float64           `json:"max_cost_usd"`
	SkipPr                 bool               `json:"skip_pr"`
	Model                  *string            `json:"model"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) error {
	_, err := q.db.Exec(ctx, createTask,
		arg.ID,
		arg.RepoID,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.DependsOn,
		arg.Attempt,
		arg.MaxAttempts,
		arg.AcceptanceCriteriaList,
		arg.MaxCostUsd,
		arg.SkipPr,
		arg.Model,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteTaskLogs = `-- name: DeleteTaskLogs :exec
DELETE FROM task_log WHERE task_id = $1
`

func (q *Queries) DeleteTaskLogs(ctx context.Context, taskID string) error {
	_, err := q.db.Exec(ctx, deleteTaskLogs, taskID)
	return err
}

const feedbackRetryTask = `-- name: FeedbackRetryTask :execrows
UPDATE task SET status = 'pending', attempt = 1,
  retry_reason = $2, agent_status = NULL,
  consecutive_failures = 0,
  started_at = NULL, updated_at = NOW()
WHERE id = $1 AND status = 'review'
`

type FeedbackRetryTaskParams struct {
	ID          string  `json:"id"`
	RetryReason *string `json:"retry_reason"`
}

func (q *Queries) FeedbackRetryTask(ctx context.Context, arg FeedbackRetryTaskParams) (int64, error) {
	result, err := q.db.Exec(ctx, feedbackRetryTask, arg.ID, arg.RetryReason)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const hasTasksForRepo = `-- name: HasTasksForRepo :one
SELECT EXISTS(SELECT 1 FROM task WHERE repo_id = $1)
`

func (q *Queries) HasTasksForRepo(ctx context.Context, repoID string) (bool, error) {
	row := q.db.QueryRow(ctx, hasTasksForRepo, repoID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listPendingTasks = `-- name: ListPendingTasks :many
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, agent_status, retry_context, consecutive_failures, cost_usd, max_cost_usd, created_at, updated_at, skip_pr, branch_name, title, acceptance_criteria_list, model, started_at FROM task WHERE status = 'pending' ORDER BY created_at ASC
`

func (q *Queries) ListPendingTasks(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.Query(ctx, listPendingTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Description,
			&i.Status,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.Attempt,
			&i.MaxAttempts,
			&i.RetryReason,
			&i.AgentStatus,
			&i.RetryContext,
			&i.ConsecutiveFailures,
			&i.CostUsd,
			&i.MaxCostUsd,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SkipPr,
			&i.BranchName,
			&i.Title,
			&i.AcceptanceCriteriaList,
			&i.Model,
			&i.StartedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingTasksByRepos = `-- name: ListPendingTasksByRepos :many
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, agent_status, retry_context, consecutive_failures, cost_usd, max_cost_usd, created_at, updated_at, skip_pr, branch_name, title, acceptance_criteria_list, model, started_at FROM task WHERE status = 'pending' AND repo_id = ANY($1::text[]) ORDER BY created_at ASC
`

func (q *Queries) ListPendingTasksByRepos(ctx context.Context, dollar_1 []string) ([]*Task, error) {
	rows, err := q.db.Query(ctx, listPendingTasksByRepos, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Description,
			&i.Status,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.Attempt,
			&i.MaxAttempts,
			&i.RetryReason,
			&i.AgentStatus,
			&i.RetryContext,
			&i.ConsecutiveFailures,
			&i.CostUsd,
			&i.MaxCostUsd,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SkipPr,
			&i.BranchName,
			&i.Title,
			&i.AcceptanceCriteriaList,
			&i.Model,
			&i.StartedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasks = `-- name: ListTasks :many
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, agent_status, retry_context, consecutive_failures, cost_usd, max_cost_usd, created_at, updated_at, skip_pr, branch_name, title, acceptance_criteria_list, model, started_at FROM task ORDER BY created_at DESC
`

func (q *Queries) ListTasks(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.Query(ctx, listTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Description,
			&i.Status,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.Attempt,
			&i.MaxAttempts,
			&i.RetryReason,
			&i.AgentStatus,
			&i.RetryContext,
			&i.ConsecutiveFailures,
			&i.CostUsd,
			&i.MaxCostUsd,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SkipPr,
			&i.BranchName,
			&i.Title,
			&i.AcceptanceCriteriaList,
			&i.Model,
			&i.StartedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksByRepo = `-- name: ListTasksByRepo :many
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, agent_status, retry_context, consecutive_failures, cost_usd, max_cost_usd, created_at, updated_at, skip_pr, branch_name, title, acceptance_criteria_list, model, started_at FROM task WHERE repo_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListTasksByRepo(ctx context.Context, repoID string) ([]*Task, error) {
	rows, err := q.db.Query(ctx, listTasksByRepo, repoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Description,
			&i.Status,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.Attempt,
			&i.MaxAttempts,
			&i.RetryReason,
			&i.AgentStatus,
			&i.RetryContext,
			&i.ConsecutiveFailures,
			&i.CostUsd,
			&i.MaxCostUsd,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SkipPr,
			&i.BranchName,
			&i.Title,
			&i.AcceptanceCriteriaList,
			&i.Model,
			&i.StartedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksInReview = `-- name: ListTasksInReview :many
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, agent_status, retry_context, consecutive_failures, cost_usd, max_cost_usd, created_at, updated_at, skip_pr, branch_name, title, acceptance_criteria_list, model, started_at FROM task WHERE status = 'review'
`

func (q *Queries) ListTasksInReview(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.Query(ctx, listTasksInReview)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Description,
			&i.Status,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.Attempt,
			&i.MaxAttempts,
			&i.RetryReason,
			&i.AgentStatus,
			&i.RetryContext,
			&i.ConsecutiveFailures,
			&i.CostUsd,
			&i.MaxCostUsd,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SkipPr,
			&i.BranchName,
			&i.Title,
			&i.AcceptanceCriteriaList,
			&i.Model,
			&i.StartedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksInReviewByRepo = `-- name: ListTasksInReviewByRepo :many
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, agent_status, retry_context, consecutive_failures, cost_usd, max_cost_usd, created_at, updated_at, skip_pr, branch_name, title, acceptance_criteria_list, model, started_at FROM task WHERE repo_id = $1 AND status = 'review'
`

func (q *Queries) ListTasksInReviewByRepo(ctx context.Context, repoID string) ([]*Task, error) {
	rows, err := q.db.Query(ctx, listTasksInReviewByRepo, repoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Description,
			&i.Status,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.Attempt,
			&i.MaxAttempts,
			&i.RetryReason,
			&i.AgentStatus,
			&i.RetryContext,
			&i.ConsecutiveFailures,
			&i.CostUsd,
			&i.MaxCostUsd,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SkipPr,
			&i.BranchName,
			&i.Title,
			&i.AcceptanceCriteriaList,
			&i.Model,
			&i.StartedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksInReviewNoPR = `-- name: ListTasksInReviewNoPR :many
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, agent_status, retry_context, consecutive_failures, cost_usd, max_cost_usd, created_at, updated_at, skip_pr, branch_name, title, acceptance_criteria_list, model, started_at FROM task WHERE status = 'review' AND branch_name IS NOT NULL AND pr_number IS NULL
`

func (q *Queries) ListTasksInReviewNoPR(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.Query(ctx, listTasksInReviewNoPR)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Description,
			&i.Status,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.Attempt,
			&i.MaxAttempts,
			&i.RetryReason,
			&i.AgentStatus,
			&i.RetryContext,
			&i.ConsecutiveFailures,
			&i.CostUsd,
			&i.MaxCostUsd,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SkipPr,
			&i.BranchName,
			&i.Title,
			&i.AcceptanceCriteriaList,
			&i.Model,
			&i.StartedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const manualRetryTask = `-- name: ManualRetryTask :execrows
UPDATE task SET status = 'pending', attempt = attempt + 1,
  retry_reason = $2, retry_context = NULL, agent_status = NULL,
  close_reason = NULL, consecutive_failures = 0,
  pull_request_url = NULL, pr_number = NULL, branch_name = NULL,
  started_at = NULL, updated_at = NOW()
WHERE id = $1 AND status = 'failed'
`

type ManualRetryTaskParams struct {
	ID          string  `json:"id"`
	RetryReason *string `json:"retry_reason"`
}

func (q *Queries) ManualRetryTask(ctx context.Context, arg ManualRetryTaskParams) (int64, error) {
	result, err := q.db.Exec(ctx, manualRetryTask, arg.ID, arg.RetryReason)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const readTask = `-- name: ReadTask :one
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, agent_status, retry_context, consecutive_failures, cost_usd, max_cost_usd, created_at, updated_at, skip_pr, branch_name, title, acceptance_criteria_list, model, started_at FROM task WHERE id = $1
`

func (q *Queries) ReadTask(ctx context.Context, id string) (*Task, error) {
	row := q.db.QueryRow(ctx, readTask, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.RepoID,
		&i.Description,
		&i.Status,
		&i.PullRequestUrl,
		&i.PrNumber,
		&i.DependsOn,
		&i.CloseReason,
		&i.Attempt,
		&i.MaxAttempts,
		&i.RetryReason,
		&i.AgentStatus,
		&i.RetryContext,
		&i.ConsecutiveFailures,
		&i.CostUsd,
		&i.MaxCostUsd,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SkipPr,
		&i.BranchName,
		&i.Title,
		&i.AcceptanceCriteriaList,
		&i.Model,
		&i.StartedAt,
	)
	return &i, err
}

const readTaskLogs = `-- name: ReadTaskLogs :many
SELECT attempt, lines FROM task_log WHERE task_id = $1 ORDER BY id
`

type ReadTaskLogsRow struct {
	Attempt int32    `json:"attempt"`
	Lines   []string `json:"lines"`
}

func (q *Queries) ReadTaskLogs(ctx context.Context, id string) ([]*ReadTaskLogsRow, error) {
	rows, err := q.db.Query(ctx, readTaskLogs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ReadTaskLogsRow
	for rows.Next() {
		var i ReadTaskLogsRow
		if err := rows.Scan(&i.Attempt, &i.Lines); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readTaskStatus = `-- name: ReadTaskStatus :one
SELECT status FROM task WHERE id = $1
`

func (q *Queries) ReadTaskStatus(ctx context.Context, id string) (TaskStatus, error) {
	row := q.db.QueryRow(ctx, readTaskStatus, id)
	var status TaskStatus
	err := row.Scan(&status)
	return status, err
}

const removeDependency = `-- name: RemoveDependency :exec
UPDATE task SET depends_on = array_remove(depends_on, $2), updated_at = NOW()
WHERE id = $1
`

type RemoveDependencyParams struct {
	ID          string      `json:"id"`
	ArrayRemove interface{} `json:"array_remove"`
}

func (q *Queries) RemoveDependency(ctx context.Context, arg RemoveDependencyParams) error {
	_, err := q.db.Exec(ctx, removeDependency, arg.ID, arg.ArrayRemove)
	return err
}

const retryTask = `-- name: RetryTask :execrows
UPDATE task SET status = 'pending', attempt = attempt + 1, retry_reason = $2, agent_status = NULL, started_at = NULL, updated_at = NOW()
WHERE id = $1 AND status = 'review'
`

type RetryTaskParams struct {
	ID          string  `json:"id"`
	RetryReason *string `json:"retry_reason"`
}

func (q *Queries) RetryTask(ctx context.Context, arg RetryTaskParams) (int64, error) {
	result, err := q.db.Exec(ctx, retryTask, arg.ID, arg.RetryReason)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const setAgentStatus = `-- name: SetAgentStatus :exec
UPDATE task SET agent_status = $2, updated_at = NOW() WHERE id = $1
`

type SetAgentStatusParams struct {
	ID          string  `json:"id"`
	AgentStatus *string `json:"agent_status"`
}

func (q *Queries) SetAgentStatus(ctx context.Context, arg SetAgentStatusParams) error {
	_, err := q.db.Exec(ctx, setAgentStatus, arg.ID, arg.AgentStatus)
	return err
}

const setBranchName = `-- name: SetBranchName :exec
UPDATE task SET branch_name = $2, status = 'review', updated_at = NOW() WHERE id = $1
`

type SetBranchNameParams struct {
	ID         string  `json:"id"`
	BranchName *string `json:"branch_name"`
}

func (q *Queries) SetBranchName(ctx context.Context, arg SetBranchNameParams) error {
	_, err := q.db.Exec(ctx, setBranchName, arg.ID, arg.BranchName)
	return err
}

const setCloseReason = `-- name: SetCloseReason :exec
UPDATE task SET close_reason = $2, updated_at = NOW() WHERE id = $1
`

type SetCloseReasonParams struct {
	ID          string  `json:"id"`
	CloseReason *string `json:"close_reason"`
}

func (q *Queries) SetCloseReason(ctx context.Context, arg SetCloseReasonParams) error {
	_, err := q.db.Exec(ctx, setCloseReason, arg.ID, arg.CloseReason)
	return err
}

const setConsecutiveFailures = `-- name: SetConsecutiveFailures :exec
UPDATE task SET consecutive_failures = $2, updated_at = NOW() WHERE id = $1
`

type SetConsecutiveFailuresParams struct {
	ID                  string `json:"id"`
	ConsecutiveFailures int32  `json:"consecutive_failures"`
}

func (q *Queries) SetConsecutiveFailures(ctx context.Context, arg SetConsecutiveFailuresParams) error {
	_, err := q.db.Exec(ctx, setConsecutiveFailures, arg.ID, arg.ConsecutiveFailures)
	return err
}

const setRetryContext = `-- name: SetRetryContext :exec
UPDATE task SET retry_context = $2, updated_at = NOW() WHERE id = $1
`

type SetRetryContextParams struct {
	ID           string  `json:"id"`
	RetryContext *string `json:"retry_context"`
}

func (q *Queries) SetRetryContext(ctx context.Context, arg SetRetryContextParams) error {
	_, err := q.db.Exec(ctx, setRetryContext, arg.ID, arg.RetryContext)
	return err
}

const setTaskPullRequest = `-- name: SetTaskPullRequest :exec
UPDATE task SET pull_request_url = $2, pr_number = $3, status = 'review', updated_at = NOW()
WHERE id = $1
`

type SetTaskPullRequestParams struct {
	ID             string  `json:"id"`
	PullRequestUrl *string `json:"pull_request_url"`
	PrNumber       *int32  `json:"pr_number"`
}

func (q *Queries) SetTaskPullRequest(ctx context.Context, arg SetTaskPullRequestParams) error {
	_, err := q.db.Exec(ctx, setTaskPullRequest, arg.ID, arg.PullRequestUrl, arg.PrNumber)
	return err
}

const taskExists = `-- name: TaskExists :one
SELECT EXISTS(SELECT 1 FROM task WHERE id = $1)
`

func (q *Queries) TaskExists(ctx context.Context, id string) (bool, error) {
	row := q.db.QueryRow(ctx, taskExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateTaskStatus = `-- name: UpdateTaskStatus :exec
UPDATE task SET status = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateTaskStatusParams struct {
	ID     string     `json:"id"`
	Status TaskStatus `json:"status"`
}

func (q *Queries) UpdateTaskStatus(ctx context.Context, arg UpdateTaskStatusParams) error {
	_, err := q.db.Exec(ctx, updateTaskStatus, arg.ID, arg.Status)
	return err
}
