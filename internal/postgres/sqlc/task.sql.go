// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: task.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const appendTaskLogs = `-- name: AppendTaskLogs :exec
INSERT INTO task_log (task_id, lines) VALUES ($1, $2)
`

type AppendTaskLogsParams struct {
	ID    string   `json:"id"`
	Lines []string `json:"lines"`
}

func (q *Queries) AppendTaskLogs(ctx context.Context, arg AppendTaskLogsParams) error {
	_, err := q.db.Exec(ctx, appendTaskLogs, arg.ID, arg.Lines)
	return err
}

const claimTask = `-- name: ClaimTask :execrows
UPDATE task SET status = 'running', updated_at = NOW()
WHERE id = $1 AND status = 'pending'
`

func (q *Queries) ClaimTask(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, claimTask, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const closeTask = `-- name: CloseTask :exec
UPDATE task SET status = 'closed', close_reason = $2, updated_at = NOW()
WHERE id = $1
`

type CloseTaskParams struct {
	ID          string  `json:"id"`
	CloseReason *string `json:"close_reason"`
}

func (q *Queries) CloseTask(ctx context.Context, arg CloseTaskParams) error {
	_, err := q.db.Exec(ctx, closeTask, arg.ID, arg.CloseReason)
	return err
}

const createTask = `-- name: CreateTask :exec
INSERT INTO task (id, repo_id, description, status, depends_on, attempt, max_attempts, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type CreateTaskParams struct {
	ID          string             `json:"id"`
	RepoID      string             `json:"repo_id"`
	Description string             `json:"description"`
	Status      TaskStatus         `json:"status"`
	DependsOn   []string           `json:"depends_on"`
	Attempt     int32              `json:"attempt"`
	MaxAttempts int32              `json:"max_attempts"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) error {
	_, err := q.db.Exec(ctx, createTask,
		arg.ID,
		arg.RepoID,
		arg.Description,
		arg.Status,
		arg.DependsOn,
		arg.Attempt,
		arg.MaxAttempts,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const hasTasksForRepo = `-- name: HasTasksForRepo :one
SELECT EXISTS(SELECT 1 FROM task WHERE repo_id = $1)
`

func (q *Queries) HasTasksForRepo(ctx context.Context, repoID string) (bool, error) {
	row := q.db.QueryRow(ctx, hasTasksForRepo, repoID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listPendingTasks = `-- name: ListPendingTasks :many
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, created_at, updated_at FROM task WHERE status = 'pending' ORDER BY created_at ASC
`

func (q *Queries) ListPendingTasks(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.Query(ctx, listPendingTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Description,
			&i.Status,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.Attempt,
			&i.MaxAttempts,
			&i.RetryReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingTasksByRepos = `-- name: ListPendingTasksByRepos :many
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, created_at, updated_at FROM task WHERE status = 'pending' AND repo_id = ANY($1::text[]) ORDER BY created_at ASC
`

func (q *Queries) ListPendingTasksByRepos(ctx context.Context, dollar_1 []string) ([]*Task, error) {
	rows, err := q.db.Query(ctx, listPendingTasksByRepos, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Description,
			&i.Status,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.Attempt,
			&i.MaxAttempts,
			&i.RetryReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasks = `-- name: ListTasks :many
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, created_at, updated_at FROM task ORDER BY created_at DESC
`

func (q *Queries) ListTasks(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.Query(ctx, listTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Description,
			&i.Status,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.Attempt,
			&i.MaxAttempts,
			&i.RetryReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksByRepo = `-- name: ListTasksByRepo :many
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, created_at, updated_at FROM task WHERE repo_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListTasksByRepo(ctx context.Context, repoID string) ([]*Task, error) {
	rows, err := q.db.Query(ctx, listTasksByRepo, repoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Description,
			&i.Status,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.Attempt,
			&i.MaxAttempts,
			&i.RetryReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksInReview = `-- name: ListTasksInReview :many
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, created_at, updated_at FROM task WHERE status = 'review'
`

func (q *Queries) ListTasksInReview(ctx context.Context) ([]*Task, error) {
	rows, err := q.db.Query(ctx, listTasksInReview)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Description,
			&i.Status,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.Attempt,
			&i.MaxAttempts,
			&i.RetryReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksInReviewByRepo = `-- name: ListTasksInReviewByRepo :many
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, created_at, updated_at FROM task WHERE repo_id = $1 AND status = 'review'
`

func (q *Queries) ListTasksInReviewByRepo(ctx context.Context, repoID string) ([]*Task, error) {
	rows, err := q.db.Query(ctx, listTasksInReviewByRepo, repoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Description,
			&i.Status,
			&i.PullRequestUrl,
			&i.PrNumber,
			&i.DependsOn,
			&i.CloseReason,
			&i.Attempt,
			&i.MaxAttempts,
			&i.RetryReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readTask = `-- name: ReadTask :one
SELECT id, repo_id, description, status, pull_request_url, pr_number, depends_on, close_reason, attempt, max_attempts, retry_reason, created_at, updated_at FROM task WHERE id = $1
`

func (q *Queries) ReadTask(ctx context.Context, id string) (*Task, error) {
	row := q.db.QueryRow(ctx, readTask, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.RepoID,
		&i.Description,
		&i.Status,
		&i.PullRequestUrl,
		&i.PrNumber,
		&i.DependsOn,
		&i.CloseReason,
		&i.Attempt,
		&i.MaxAttempts,
		&i.RetryReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const readTaskLogs = `-- name: ReadTaskLogs :many
SELECT lines FROM task_log WHERE task_id = $1 ORDER BY id
`

func (q *Queries) ReadTaskLogs(ctx context.Context, id string) ([][]string, error) {
	rows, err := q.db.Query(ctx, readTaskLogs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items [][]string
	for rows.Next() {
		var lines []string
		if err := rows.Scan(&lines); err != nil {
			return nil, err
		}
		items = append(items, lines)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readTaskStatus = `-- name: ReadTaskStatus :one
SELECT status FROM task WHERE id = $1
`

func (q *Queries) ReadTaskStatus(ctx context.Context, id string) (TaskStatus, error) {
	row := q.db.QueryRow(ctx, readTaskStatus, id)
	var status TaskStatus
	err := row.Scan(&status)
	return status, err
}

const retryTask = `-- name: RetryTask :execrows
UPDATE task SET status = 'pending', attempt = attempt + 1, retry_reason = $2, updated_at = NOW()
WHERE id = $1 AND status = 'review'
`

type RetryTaskParams struct {
	ID          string  `json:"id"`
	RetryReason *string `json:"retry_reason"`
}

func (q *Queries) RetryTask(ctx context.Context, arg RetryTaskParams) (int64, error) {
	result, err := q.db.Exec(ctx, retryTask, arg.ID, arg.RetryReason)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const setTaskPullRequest = `-- name: SetTaskPullRequest :exec
UPDATE task SET pull_request_url = $2, pr_number = $3, status = 'review', updated_at = NOW()
WHERE id = $1
`

type SetTaskPullRequestParams struct {
	ID             string  `json:"id"`
	PullRequestUrl *string `json:"pull_request_url"`
	PrNumber       *int32  `json:"pr_number"`
}

func (q *Queries) SetTaskPullRequest(ctx context.Context, arg SetTaskPullRequestParams) error {
	_, err := q.db.Exec(ctx, setTaskPullRequest, arg.ID, arg.PullRequestUrl, arg.PrNumber)
	return err
}

const taskExists = `-- name: TaskExists :one
SELECT EXISTS(SELECT 1 FROM task WHERE id = $1)
`

func (q *Queries) TaskExists(ctx context.Context, id string) (bool, error) {
	row := q.db.QueryRow(ctx, taskExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateTaskStatus = `-- name: UpdateTaskStatus :exec
UPDATE task SET status = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateTaskStatusParams struct {
	ID     string     `json:"id"`
	Status TaskStatus `json:"status"`
}

func (q *Queries) UpdateTaskStatus(ctx context.Context, arg UpdateTaskStatusParams) error {
	_, err := q.db.Exec(ctx, updateTaskStatus, arg.ID, arg.Status)
	return err
}
