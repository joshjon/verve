// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: epic.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const appendSessionLog = `-- name: AppendSessionLog :exec
UPDATE epic SET session_log = session_log || $2, updated_at = NOW()
WHERE id = $1
`

type AppendSessionLogParams struct {
	ID         string   `json:"id"`
	SessionLog []string `json:"session_log"`
}

func (q *Queries) AppendSessionLog(ctx context.Context, arg AppendSessionLogParams) error {
	_, err := q.db.Exec(ctx, appendSessionLog, arg.ID, arg.SessionLog)
	return err
}

const claimEpic = `-- name: ClaimEpic :execrows
UPDATE epic SET
  claimed_at = NOW(),
  last_heartbeat_at = NOW(),
  updated_at = NOW()
WHERE id = $1 AND status = 'planning' AND claimed_at IS NULL
`

func (q *Queries) ClaimEpic(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, claimEpic, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const clearEpicFeedback = `-- name: ClearEpicFeedback :exec
UPDATE epic SET
  feedback = NULL,
  feedback_type = NULL,
  updated_at = NOW()
WHERE id = $1
`

func (q *Queries) ClearEpicFeedback(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, clearEpicFeedback, id)
	return err
}

const createEpic = `-- name: CreateEpic :exec
INSERT INTO epic (id, repo_id, title, description, status, proposed_tasks, task_ids, planning_prompt, session_log, not_ready, model, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
`

type CreateEpicParams struct {
	ID             string             `json:"id"`
	RepoID         string             `json:"repo_id"`
	Title          string             `json:"title"`
	Description    string             `json:"description"`
	Status         string             `json:"status"`
	ProposedTasks  []byte             `json:"proposed_tasks"`
	TaskIds        []string           `json:"task_ids"`
	PlanningPrompt *string            `json:"planning_prompt"`
	SessionLog     []string           `json:"session_log"`
	NotReady       bool               `json:"not_ready"`
	Model          *string            `json:"model"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateEpic(ctx context.Context, arg CreateEpicParams) error {
	_, err := q.db.Exec(ctx, createEpic,
		arg.ID,
		arg.RepoID,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.ProposedTasks,
		arg.TaskIds,
		arg.PlanningPrompt,
		arg.SessionLog,
		arg.NotReady,
		arg.Model,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteEpic = `-- name: DeleteEpic :exec
DELETE FROM epic WHERE id = $1
`

func (q *Queries) DeleteEpic(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteEpic, id)
	return err
}

const epicHeartbeat = `-- name: EpicHeartbeat :exec
UPDATE epic SET
  last_heartbeat_at = NOW(),
  updated_at = NOW()
WHERE id = $1
`

func (q *Queries) EpicHeartbeat(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, epicHeartbeat, id)
	return err
}

const listEpics = `-- name: ListEpics :many
SELECT id, repo_id, title, description, status, proposed_tasks, task_ids, planning_prompt, session_log, not_ready, created_at, updated_at, claimed_at, last_heartbeat_at, feedback, feedback_type, model FROM epic ORDER BY created_at DESC
`

func (q *Queries) ListEpics(ctx context.Context) ([]*Epic, error) {
	rows, err := q.db.Query(ctx, listEpics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Epic
	for rows.Next() {
		var i Epic
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.ProposedTasks,
			&i.TaskIds,
			&i.PlanningPrompt,
			&i.SessionLog,
			&i.NotReady,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClaimedAt,
			&i.LastHeartbeatAt,
			&i.Feedback,
			&i.FeedbackType,
			&i.Model,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpicsByRepo = `-- name: ListEpicsByRepo :many
SELECT id, repo_id, title, description, status, proposed_tasks, task_ids, planning_prompt, session_log, not_ready, created_at, updated_at, claimed_at, last_heartbeat_at, feedback, feedback_type, model FROM epic WHERE repo_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListEpicsByRepo(ctx context.Context, repoID string) ([]*Epic, error) {
	rows, err := q.db.Query(ctx, listEpicsByRepo, repoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Epic
	for rows.Next() {
		var i Epic
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.ProposedTasks,
			&i.TaskIds,
			&i.PlanningPrompt,
			&i.SessionLog,
			&i.NotReady,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClaimedAt,
			&i.LastHeartbeatAt,
			&i.Feedback,
			&i.FeedbackType,
			&i.Model,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlanningEpics = `-- name: ListPlanningEpics :many
SELECT id, repo_id, title, description, status, proposed_tasks, task_ids, planning_prompt, session_log, not_ready, created_at, updated_at, claimed_at, last_heartbeat_at, feedback, feedback_type, model FROM epic
WHERE status = 'planning' AND claimed_at IS NULL
ORDER BY created_at ASC
`

func (q *Queries) ListPlanningEpics(ctx context.Context) ([]*Epic, error) {
	rows, err := q.db.Query(ctx, listPlanningEpics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Epic
	for rows.Next() {
		var i Epic
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.ProposedTasks,
			&i.TaskIds,
			&i.PlanningPrompt,
			&i.SessionLog,
			&i.NotReady,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClaimedAt,
			&i.LastHeartbeatAt,
			&i.Feedback,
			&i.FeedbackType,
			&i.Model,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStaleEpics = `-- name: ListStaleEpics :many
SELECT id, repo_id, title, description, status, proposed_tasks, task_ids, planning_prompt, session_log, not_ready, created_at, updated_at, claimed_at, last_heartbeat_at, feedback, feedback_type, model FROM epic
WHERE claimed_at IS NOT NULL
  AND last_heartbeat_at < $1
  AND status IN ('planning', 'draft')
ORDER BY last_heartbeat_at ASC
`

func (q *Queries) ListStaleEpics(ctx context.Context, lastHeartbeatAt pgtype.Timestamptz) ([]*Epic, error) {
	rows, err := q.db.Query(ctx, listStaleEpics, lastHeartbeatAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Epic
	for rows.Next() {
		var i Epic
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.ProposedTasks,
			&i.TaskIds,
			&i.PlanningPrompt,
			&i.SessionLog,
			&i.NotReady,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClaimedAt,
			&i.LastHeartbeatAt,
			&i.Feedback,
			&i.FeedbackType,
			&i.Model,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readEpic = `-- name: ReadEpic :one
SELECT id, repo_id, title, description, status, proposed_tasks, task_ids, planning_prompt, session_log, not_ready, created_at, updated_at, claimed_at, last_heartbeat_at, feedback, feedback_type, model FROM epic WHERE id = $1
`

func (q *Queries) ReadEpic(ctx context.Context, id string) (*Epic, error) {
	row := q.db.QueryRow(ctx, readEpic, id)
	var i Epic
	err := row.Scan(
		&i.ID,
		&i.RepoID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.ProposedTasks,
		&i.TaskIds,
		&i.PlanningPrompt,
		&i.SessionLog,
		&i.NotReady,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClaimedAt,
		&i.LastHeartbeatAt,
		&i.Feedback,
		&i.FeedbackType,
		&i.Model,
	)
	return &i, err
}

const releaseEpicClaim = `-- name: ReleaseEpicClaim :exec
UPDATE epic SET
  claimed_at = NULL,
  last_heartbeat_at = NULL,
  status = 'planning',
  updated_at = NOW()
WHERE id = $1
`

func (q *Queries) ReleaseEpicClaim(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, releaseEpicClaim, id)
	return err
}

const setEpicFeedback = `-- name: SetEpicFeedback :exec
UPDATE epic SET
  feedback = $2,
  feedback_type = $3,
  updated_at = NOW()
WHERE id = $1
`

type SetEpicFeedbackParams struct {
	ID           string  `json:"id"`
	Feedback     *string `json:"feedback"`
	FeedbackType *string `json:"feedback_type"`
}

func (q *Queries) SetEpicFeedback(ctx context.Context, arg SetEpicFeedbackParams) error {
	_, err := q.db.Exec(ctx, setEpicFeedback, arg.ID, arg.Feedback, arg.FeedbackType)
	return err
}

const setEpicTaskIDs = `-- name: SetEpicTaskIDs :exec
UPDATE epic SET task_ids = $2, updated_at = NOW()
WHERE id = $1
`

type SetEpicTaskIDsParams struct {
	ID      string   `json:"id"`
	TaskIds []string `json:"task_ids"`
}

func (q *Queries) SetEpicTaskIDs(ctx context.Context, arg SetEpicTaskIDsParams) error {
	_, err := q.db.Exec(ctx, setEpicTaskIDs, arg.ID, arg.TaskIds)
	return err
}

const updateEpic = `-- name: UpdateEpic :exec
UPDATE epic SET
  title = $2,
  description = $3,
  status = $4,
  proposed_tasks = $5,
  task_ids = $6,
  planning_prompt = $7,
  session_log = $8,
  not_ready = $9,
  model = $10,
  updated_at = NOW()
WHERE id = $1
`

type UpdateEpicParams struct {
	ID             string   `json:"id"`
	Title          string   `json:"title"`
	Description    string   `json:"description"`
	Status         string   `json:"status"`
	ProposedTasks  []byte   `json:"proposed_tasks"`
	TaskIds        []string `json:"task_ids"`
	PlanningPrompt *string  `json:"planning_prompt"`
	SessionLog     []string `json:"session_log"`
	NotReady       bool     `json:"not_ready"`
	Model          *string  `json:"model"`
}

func (q *Queries) UpdateEpic(ctx context.Context, arg UpdateEpicParams) error {
	_, err := q.db.Exec(ctx, updateEpic,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.ProposedTasks,
		arg.TaskIds,
		arg.PlanningPrompt,
		arg.SessionLog,
		arg.NotReady,
		arg.Model,
	)
	return err
}

const updateEpicStatus = `-- name: UpdateEpicStatus :exec
UPDATE epic SET status = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateEpicStatusParams struct {
	ID     string `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) UpdateEpicStatus(ctx context.Context, arg UpdateEpicStatusParams) error {
	_, err := q.db.Exec(ctx, updateEpicStatus, arg.ID, arg.Status)
	return err
}

const updateProposedTasks = `-- name: UpdateProposedTasks :exec
UPDATE epic SET proposed_tasks = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateProposedTasksParams struct {
	ID            string `json:"id"`
	ProposedTasks []byte `json:"proposed_tasks"`
}

func (q *Queries) UpdateProposedTasks(ctx context.Context, arg UpdateProposedTasksParams) error {
	_, err := q.db.Exec(ctx, updateProposedTasks, arg.ID, arg.ProposedTasks)
	return err
}
