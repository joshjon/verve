// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: epic.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const appendSessionLog = `-- name: AppendSessionLog :exec
UPDATE epic SET session_log = session_log || $2, updated_at = NOW()
WHERE id = $1
`

type AppendSessionLogParams struct {
	ID         string   `json:"id"`
	SessionLog []string `json:"session_log"`
}

func (q *Queries) AppendSessionLog(ctx context.Context, arg AppendSessionLogParams) error {
	_, err := q.db.Exec(ctx, appendSessionLog, arg.ID, arg.SessionLog)
	return err
}

const createEpic = `-- name: CreateEpic :exec
INSERT INTO epic (id, repo_id, title, description, status, proposed_tasks, task_ids, planning_prompt, session_log, not_ready, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
`

type CreateEpicParams struct {
	ID             string             `json:"id"`
	RepoID         string             `json:"repo_id"`
	Title          string             `json:"title"`
	Description    string             `json:"description"`
	Status         string             `json:"status"`
	ProposedTasks  []byte             `json:"proposed_tasks"`
	TaskIds        []string           `json:"task_ids"`
	PlanningPrompt *string            `json:"planning_prompt"`
	SessionLog     []string           `json:"session_log"`
	NotReady       bool               `json:"not_ready"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateEpic(ctx context.Context, arg CreateEpicParams) error {
	_, err := q.db.Exec(ctx, createEpic,
		arg.ID,
		arg.RepoID,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.ProposedTasks,
		arg.TaskIds,
		arg.PlanningPrompt,
		arg.SessionLog,
		arg.NotReady,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteEpic = `-- name: DeleteEpic :exec
DELETE FROM epic WHERE id = $1
`

func (q *Queries) DeleteEpic(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteEpic, id)
	return err
}

const listEpics = `-- name: ListEpics :many
SELECT id, repo_id, title, description, status, proposed_tasks, task_ids, planning_prompt, session_log, not_ready, created_at, updated_at FROM epic ORDER BY created_at DESC
`

func (q *Queries) ListEpics(ctx context.Context) ([]*Epic, error) {
	rows, err := q.db.Query(ctx, listEpics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Epic
	for rows.Next() {
		var i Epic
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.ProposedTasks,
			&i.TaskIds,
			&i.PlanningPrompt,
			&i.SessionLog,
			&i.NotReady,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpicsByRepo = `-- name: ListEpicsByRepo :many
SELECT id, repo_id, title, description, status, proposed_tasks, task_ids, planning_prompt, session_log, not_ready, created_at, updated_at FROM epic WHERE repo_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListEpicsByRepo(ctx context.Context, repoID string) ([]*Epic, error) {
	rows, err := q.db.Query(ctx, listEpicsByRepo, repoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Epic
	for rows.Next() {
		var i Epic
		if err := rows.Scan(
			&i.ID,
			&i.RepoID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.ProposedTasks,
			&i.TaskIds,
			&i.PlanningPrompt,
			&i.SessionLog,
			&i.NotReady,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readEpic = `-- name: ReadEpic :one
SELECT id, repo_id, title, description, status, proposed_tasks, task_ids, planning_prompt, session_log, not_ready, created_at, updated_at FROM epic WHERE id = $1
`

func (q *Queries) ReadEpic(ctx context.Context, id string) (*Epic, error) {
	row := q.db.QueryRow(ctx, readEpic, id)
	var i Epic
	err := row.Scan(
		&i.ID,
		&i.RepoID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.ProposedTasks,
		&i.TaskIds,
		&i.PlanningPrompt,
		&i.SessionLog,
		&i.NotReady,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const setEpicTaskIDs = `-- name: SetEpicTaskIDs :exec
UPDATE epic SET task_ids = $2, updated_at = NOW()
WHERE id = $1
`

type SetEpicTaskIDsParams struct {
	ID      string   `json:"id"`
	TaskIds []string `json:"task_ids"`
}

func (q *Queries) SetEpicTaskIDs(ctx context.Context, arg SetEpicTaskIDsParams) error {
	_, err := q.db.Exec(ctx, setEpicTaskIDs, arg.ID, arg.TaskIds)
	return err
}

const updateEpic = `-- name: UpdateEpic :exec
UPDATE epic SET
  title = $2,
  description = $3,
  status = $4,
  proposed_tasks = $5,
  task_ids = $6,
  planning_prompt = $7,
  session_log = $8,
  not_ready = $9,
  updated_at = NOW()
WHERE id = $1
`

type UpdateEpicParams struct {
	ID             string   `json:"id"`
	Title          string   `json:"title"`
	Description    string   `json:"description"`
	Status         string   `json:"status"`
	ProposedTasks  []byte   `json:"proposed_tasks"`
	TaskIds        []string `json:"task_ids"`
	PlanningPrompt *string  `json:"planning_prompt"`
	SessionLog     []string `json:"session_log"`
	NotReady       bool     `json:"not_ready"`
}

func (q *Queries) UpdateEpic(ctx context.Context, arg UpdateEpicParams) error {
	_, err := q.db.Exec(ctx, updateEpic,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.ProposedTasks,
		arg.TaskIds,
		arg.PlanningPrompt,
		arg.SessionLog,
		arg.NotReady,
	)
	return err
}

const updateEpicStatus = `-- name: UpdateEpicStatus :exec
UPDATE epic SET status = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateEpicStatusParams struct {
	ID     string `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) UpdateEpicStatus(ctx context.Context, arg UpdateEpicStatusParams) error {
	_, err := q.db.Exec(ctx, updateEpicStatus, arg.ID, arg.Status)
	return err
}

const updateProposedTasks = `-- name: UpdateProposedTasks :exec
UPDATE epic SET proposed_tasks = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateProposedTasksParams struct {
	ID            string `json:"id"`
	ProposedTasks []byte `json:"proposed_tasks"`
}

func (q *Queries) UpdateProposedTasks(ctx context.Context, arg UpdateProposedTasksParams) error {
	_, err := q.db.Exec(ctx, updateProposedTasks, arg.ID, arg.ProposedTasks)
	return err
}
