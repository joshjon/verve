# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Verve is a distributed AI agent orchestrator platform. It dispatches AI coding agents to work on tasks within user infrastructure. The system has two halves:

1. **Internal Cloud** (we control): API server, Postgres database, and web UI for task management
2. **Orchestrator Worker** (user deploys): Docker container that long-polls for work, runs isolated agents, streams logs, and creates PRs

Key constraint: User source code and secrets never leave their network. We send task descriptions in; we get logs and PR notifications out.

## Important Rules

- **Never build binaries to the project root.** Always use `make build` or output to `bin/` (e.g. `go build -o bin/ ./cmd/...`). The `bin/` directory is git-ignored.

## Development Commands

```bash
# Build
make build                        # Build server and worker binaries
make build-server                 # Build API server only
make build-worker                 # Build worker only
make build-agent                  # Build agent Docker image

# Generate
make generate                     # Generate sqlc code for postgres and sqlite

# Run
make run-server                   # Start API server (port 7400, in-memory SQLite)
make run-server-pg                # Start API server with PostgreSQL
make run-worker                   # Start worker (connects to localhost:7400)

# Test
make test-task                    # Create a test task via curl
make list-tasks                   # List all tasks
make get-task ID=tsk_xxx          # Get specific task details

# Clean
make clean                        # Remove binaries and Docker image
make tidy                         # Run go mod tidy
```

## Technology Stack

- **Language**: Go 1.25+
- **HTTP Framework**: Echo v4
- **Database**: PostgreSQL (production) / SQLite in-memory (dev)
- **SQL Generation**: sqlc (via `go tool sqlc`)
- **Container Runtime**: Docker (via Docker SDK for Go)
- **Utilities**: `github.com/joshjon/kit` (pgdb, sqlitedb, errtag, id)
- **IDs**: TypeID via `go.jetify.com/typeid`

## Architecture

```
Internal Cloud                          User Environment
┌─────────────────────────┐            ┌─────────────────────────┐
│ Postgres ◄─► API Server │◄── HTTPS ──│ Orchestrator Worker     │
│              ◄─► UI     │            │   └─► Agent containers  │
└─────────────────────────┘            └─────────────────────────┘
```

## Package Structure

```
verve/
├── cmd/
│   ├── server/main.go              # API server entrypoint
│   └── worker/main.go              # Worker entrypoint
├── internal/
│   ├── app/
│   │   ├── config.go               # Config, PostgresConfig, GitHubConfig
│   │   └── run.go                  # Run (auto-selects postgres or sqlite)
│   ├── task/
│   │   ├── id.go                   # TaskID typed ID (kit/id + typeid)
│   │   ├── task.go                 # Task struct, Status enum, NewTask
│   │   ├── repository.go           # Repository interface
│   │   ├── repository_errors.go    # ErrTagTaskNotFound, ErrTagTaskConflict
│   │   └── store.go                # Store wrapping Repository + pending notification
│   ├── taskapi/
│   │   ├── http_handler.go         # HTTP handlers with Register(group)
│   │   └── http_types.go           # Request/response types
│   ├── github/
│   │   └── client.go               # GitHub API client for PR status checks
│   ├── postgres/
│   │   ├── db.go                   # DB type alias
│   │   ├── gen.go                  # //go:generate sqlc
│   │   ├── task_repo.go            # TaskRepository implements task.Repository
│   │   ├── marshal.go              # sqlc row -> domain entity conversion
│   │   ├── migrations/
│   │   │   ├── fs.go               # //go:embed *.sql
│   │   │   └── 0001_create_tasks.up.sql
│   │   ├── queries/
│   │   │   └── task.sql            # sqlc query definitions
│   │   ├── sqlc.yaml               # sqlc config (engine: postgresql, pgx/v5)
│   │   └── sqlc/                   # generated by sqlc (DO NOT EDIT)
│   ├── sqlite/
│   │   ├── db.go                   # DB type alias
│   │   ├── gen.go                  # //go:generate sqlc
│   │   ├── task_repo.go            # TaskRepository implements task.Repository
│   │   ├── marshal.go              # JSON array handling for SQLite
│   │   ├── migrations/
│   │   │   ├── fs.go               # //go:embed *.sql
│   │   │   └── 0001_create_tasks.up.sql
│   │   ├── queries/
│   │   │   └── task.sql
│   │   ├── sqlc.yaml               # sqlc config (engine: sqlite)
│   │   └── sqlc/                   # generated by sqlc (DO NOT EDIT)
│   └── worker/
│       ├── worker.go               # Polling loop and task execution
│       └── docker.go               # Docker SDK integration
├── agent/
│   ├── Dockerfile                  # Agent container image
│   └── entrypoint.sh               # Agent execution script
├── go.mod
└── Makefile
```

## Database Layer

### Repository Pattern
- Domain types and `Repository` interface defined in `internal/task/`
- PostgreSQL implementation in `internal/postgres/` using pgx/v5
- SQLite implementation in `internal/sqlite/` using database/sql + modernc.org/sqlite
- Both backends are interchangeable via the `task.Repository` interface

### SQLC Conventions
- Query files in `internal/postgres/queries/*.sql` and `internal/sqlite/queries/*.sql`
- Use `-- name: QueryName :one/:many/:exec` comment syntax
- Generated code in `*/sqlc/` directories — never edit manually
- Run `make generate` after changing queries or migrations
- SQLite stores array fields (logs, depends_on) as JSON text

### Migrations
- Embedded via `//go:embed *.sql` in `*/migrations/fs.go`
- Run automatically on server startup via `pgdb.Migrate` / `sqlitedb.Migrate`
- Follow golang-migrate naming: `NNNN_description.up.sql`

## API Structure

Base path: `/api/v1`

```
/tasks
├── POST                     # Create task
├── GET                      # List all tasks
├── /sync                    # POST sync all tasks in review
├── /poll                    # GET long-poll for pending tasks
└── /{task_id}
    ├── GET                  # Get task details with logs
    ├── /logs                # POST logs from worker
    ├── /complete            # POST completion status from worker
    ├── /close               # POST close task with reason
    └── /sync                # POST sync single task PR status
```

## Worker-Cloud Communication

Worker communicates with API server via REST/JSON:
- `GET /tasks/poll`: Long-poll to claim pending tasks
- `POST /tasks/{id}/logs`: Send collected agent logs
- `POST /tasks/{id}/complete`: Report success/failure

## Entity Model

### Task Status Lifecycle
```
pending → running → review → merged
                  → closed
                  → failed
```

### Entity Identity Pattern
Use TypeID prefixes for entity IDs:
- `tsk_*` = Task (e.g., `tsk_01HQXYZ...`)

IDs use `github.com/joshjon/kit/id` with `go.jetify.com/typeid` for type-safe prefixed UUIDs.

## Key Patterns

### Error Handling
Use semantic error types via `github.com/joshjon/kit/errtag`:
- `errtag.NotFound` → 404
- `errtag.Conflict` → 409
- `errtag.InvalidArgument` → 400

Database implementations tag errors in `tagTaskErr()`:
- `pgx.ErrNoRows` / `sql.ErrNoRows` → `ErrTagTaskNotFound`
- Unique violation → `ErrTagTaskConflict`

### Store Pattern
`task.Store` wraps `task.Repository` adding:
- Dependency validation on create
- Pending task notification channel for long-poll

### Log Streaming
Worker streams logs from Docker container in real-time:
1. Attaches to container stdout/stderr with `Follow=true`
2. Demultiplexes the Docker stream using `stdcopy`
3. Buffers lines and sends batches to API server every 2 seconds (or when buffer reaches 50 lines)
4. UI can poll `/tasks/{id}` to see logs incrementally as the agent runs

### Agent Isolation
Uses Docker-in-Docker approach:
- Each task spawns an isolated Docker container
- Container receives task via environment variables (TASK_ID, TASK_DESCRIPTION)
- Container is automatically removed after execution
- Agent image: `verve-agent:latest`

## Important Notes

- User code never leaves their network - only task descriptions flow in, logs and PR notifications flow out
- Workers authenticate with per-user API keys
- Task queue uses long-polling (worker initiates connection, server holds until task available)
- Agents are ephemeral - one process per task, destroyed after completion
- PR creation happens on user side using their Git credentials
